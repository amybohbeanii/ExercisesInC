## Quiz 6 notes
1) readings 22-24
2) HFC 11 + 12
3) TOS 10 
4) Rec reading with TOS 10 is LBOS Ch3 and 4

## TOS 10: POSIX condition variables. Producer/Consumer problem

 * Use a condition variable to solve producer-consumer problem
 * in multi-threaded rograms, threads perform diff tasks. Threads communicate with each other using a queue. 
 * Some threads, "producers" put data into queue, other "consumers" take data out. 
 * example is a GUI. one thread might put requests into queue. Bad end thread might take requests out to process them
 * queue implementation is needed for both or more than two threads to access queue at the same time. "thread safe"
 * special case is when queue is empty AND (if size of queue is bounded) when queue is full
 
 * example
 
 ```
 typedef struct {
  int *array; //contains elements of queue
  int length; 
  int next_in; //index for where next element should be added
  int next_out; //index of next element that should be removed
 } Queue; 
 
 Queue *make_queue(int length){
  Queue *queue = (Queue *) malloc(sizeof(Queue));
  queue->length = length;
  queue->array = (int *) malloc(length * sizeof(int));
  queue->next_in = 0;
  queue->next_out = 0;
  return queue;
}

/*special case if queue is initially empty. No next element to remove, so next_out is invalid
int queue_empty(Queue *queue){
  return(queue->next_in == queue->next_out);
}  

/*increments next_in if queue isnt full*/
int queue_incr(Queue *queue, int i){
  return (i+1)%queue->length;
}

/*special case if queue is full. In queue_incr, at end of array it wraps around to 0 and if we keep adding next_in==next_out 
which means queue is empty. To avoid, this func is necessary*/
int queue_full(Queue *queue){
  return (queue_incr(queue,queue->next_in)==queue->next_out);
}

/*add elements to queue*/
void queue_push(Queue *queue, int item){
  if(queue_full(queue)){
    perror_exit("queue is full");
  }
  queue->array[queue->next_in] = item;
  queue->next_in = queue_incr(queue, queue->next_in); //increases next_in using func
}  

/*removes and returns next element from queue*/
int queue_pop(Queue *queue){
  if(queue_empty(queue)){
    perror_exit("queue is empty");
  }
  int item = queue->array[queue->next_out];
  queue->next_out = queue_incr(queue,queue->next_out);
  return item;
}  
```
